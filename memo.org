#+title: MEMO
#+author: matsuyoshi30

* Parsing

** parseNumber の do-notation 記法を使わない書き方

#+begin_src haskell
parseNumber = do
  n <- many1 digit
  return $ (Number . read) n
-- とか
parseNumber = many1 digit >>= return . Number . read
parseNumber = many1 digit >>= \x -> return $ (Number . read) x
#+end_src

最初に

#+begin_src haskell
parseNumber = many1 digit >>= Number . read
#+end_src

って書いてたけど間違いで、 >>= の先の関数は bind 元と同じモナドを返さないといけなかった

#+begin_src
Main.hs:45:31: error:
    • Couldn't match type ‘LispVal’
                     with ‘Text.Parsec.Prim.ParsecT
                             String () Data.Functor.Identity.Identity LispVal’
      Expected type: [Char]
                     -> Text.Parsec.Prim.ParsecT
                          String () Data.Functor.Identity.Identity LispVal
        Actual type: String -> LispVal
    • In the second argument of ‘(>>=)’, namely ‘Number . read’
      In the expression: many1 digit >>= Number . read
      In an equation for ‘parseNumber’:
          parseNumber = many1 digit >>= Number . read
   |
45 | parseNumber = many1 digit >>= Number . read
   |
#+end_src

というエラー

** parseString を \" に対応させる

エスケープ文字をパーズする関数を作る

#+begin_src haskell
escapeChar :: Parser Char
escapeChar = do
  _ <- char '\\' -- backslash
  x <- oneOf "\\\"" -- backslask or double-quote
  return x
#+end_src

** 2進数を10進数に変換する

以下の通り変換できる

#+begin_src haskell
bin2dig = bin2dig' 0
bin2dig' digint "" = digint
bin2dig' digint (x:xs) =
  let old = 2 * digint + (if x == '0' then 0 else 1)
  in bin2dig' old xs
#+end_src

10111(23)を例に見てみる

#+begin_src haskell
bin2dig "10111"

bin2dig' 0 "1":"0111" =
  let old = 2 * 0 + 1
  in big2dig' old "0111"

     big2dig' 1 "0":"111" =
       let old = 2 * 1 + 0
       in big2dig' old "111"

          bin2dig' 2 "1":"11" =
            let old = 2 * 2 + 1
            in big2dig' old "11"

               bin2dig' 5 "1":"1" =
                 let old = 2 * 5 + 1
                 in big2dig' old "1"

                    big2dig' 11 "1" =
                      let old = 2 * 11 + 1
                      in big2dig' old ""

                         big2dig' 23 "" = 23
#+end_src

** R5RS の Character 対応

https://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.4

"#\" のあとに space や newline や一文字アルファベット、数字、左括弧が来たら Character としてパーズする

#+begin_src haskell
parseCharacter = do
  ch <- try $ do
    _ <- char '#'
    _ <- char '\\'
    c <- string "space" <|> string "newline" <|> do -- space か newline か一文字 anyChar
      x <- anyChar
      _ <- notFollowedBy alphaNum -- アルファベットもしくは数字が二文字以降に続くならパーズ失敗
      return [x]
    return c
  return $ Character $ case ch of
    "space" -> ' '
    "newline" -> '\n'
    _ -> ch !! 0
#+end_src

[[https://tnomura9.exblog.jp/15060690/][notFollowedBy について]]

** Haskell の分数表記

http://labs.timedia.co.jp/2012/11/haskell-1.html

/ のかわりに % を使うと有理数計算ができる( Data.Ratio のインポートが必要)

** List のパーズ

[[https://hackage.haskell.org/package/parsec-3.1.15.0/docs/Text-Parsec-Combinator.html#v:sepBy][sepBy]] で指定された区切り文字の内容をリスト化して返す

expr1, expr2, expr3 が [expr1, expr2, expr3] になる

リストの要素は Expr

** DottedList のパーズ

[[https://groups.csail.mit.edu/mac/ftpdir/scheme-7.4/doc-html/scheme_8.html][DottedList]] scheme では (a b . c) みたいな形でリストかける improper だけど

expr1 expr2 expr3 (最後も空白あり)が [expr1, expr2, expr3] になる

[[https://hackage.haskell.org/package/parsec-3.1.15.0/docs/Text-Parsec-Combinator.html#v:endBy][endBy]] で指定された内容と区切り文字の内容をリスト化して返す

** Vector のパーズ

#( で始まる文字列を Vector としてパーズする

[[https://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.6][scheme の Vector]] は要素数が固定されているので、 Haskell-Scheme の内部的には Data.Array を用いて Array としてデータを保持する

#+begin_src haskell
parseVector = do
  es <- try $ do
    _ <- char '#'
    _ <- char '('
    vals <- sepBy parseExpr spaces -- カッコ内の要素を LispVal のリストとしてパーズ
    _ <- char ')'
    return vals
  return $ Vector (listArray (0, (length es - 1)) es) -- Data.Array の listArray でリストを Array に変換
#+end_src

* Evaluation

** 関数適用

関数が第一級オブジェクトなので引数に持てる

関数適用のケースでは、リストの戦闘要素が関数として評価できる場合、その関数の処理内容を引っ張ってきてリストの残りの引数群に適用させればよい

ここでは以下のとおり apply を実装

#+begin_src haskell
apply :: String -> [LispVal] -> LispVal
apply func args = maybe (Bool False) ($ args) $ lookup func primitives
#+end_src

primitives に事前に定義した関数をターゲットに、評価対象の文字列が lookup で引っ張ってこれるか試す

引っ張ってこれなかったら Bool False を返すが、引っ張ってくることができれば引っ張ってきた処理内容を引数 args に適用する

#+begin_src haskell
maybe :: b -> (a -> b) -> Maybe a -> b
#+end_src

maybe は、第1引数には失敗したときに返す値を、第2引数には第3引数が渡されたときに第1引数と同じ型を返す関数を渡す

ここでは第1引数は lookup が失敗したとき（ primitives に適用できる関数がなかった）に返す Bool False :: LispVal が、第2引数にはセクション化された関数適用演算子と args が、第3引数には lookup の結果が渡されている

lookup が成功したときは、その結果の値が第2引数に渡した関数に適用されて、その結果が maybe の結果として返される。そのため、第1引数の型と、第2引数の関数が返す型は同じでなければならない

中置記法の $ は関数適用演算子だが、セクション化することで引数 args を適用する、引数に関数を期待する関数として書くことができる

#+begin_src haskell
-- Prelude> :t ($ 1)
($ 1) :: Num a => (a -> b) -> b
#+end_src

** エラーチェックと例外

Maybe モナドだと「失敗したかもしれない」という文脈をもたせることはできるが、「どういう失敗をするかもしれないか」まで情報を持てない

Either モナドを使ってエラーの内容を保持するように修正する

#+begin_src haskell
type ThrowsError = Either LispError
#+end_src

別途 LispError というエラー専用の型を定義して、 Either モナドの Left にそのエラー情報を持つような新たな型 ThrowsError を定義する

ThrowsError の Right は正常処理の結果が格納されるので、 ThrowsError から値を取る関数を別途定義

#+begin_src haskell
extractValue :: ThrowsError a -> a
extractValue (Right val) = val
#+end_src

あとはエラーが発生しうる各関数の戻り値を ThrowsError で包んで、 LispError から ThrowsError LispVal にする

エラーが発生する可能性のある箇所では、事前に定義したエラー型の値インスタンスを用いてエラー情報をカスタマイズする。このとき [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Error.html#v:throwError][throwError]] 関数を用いて戻り値を ThrowsError にする

#+begin_src haskell
-- Prelude Control.Monad.Except> :t throwError
throwError :: MonadError e m => e -> m a
#+end_src

これにより、エラー情報 e を受け取りモナド値に変換する

発生したエラーは最終的にどこかで catch される必要があるが、ここでは main で行う

#+begin_src haskell
-- Prelude Control.Monad.Except> :t catchError
catchError :: MonadError e m => m a -> (e -> m a) -> m a
#+end_src

上記の通り定義されている [[https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Error.html#v:catchError][catchError]]r 関数を用いてエラーを catch する。これはモナド値 m a と、エラー情報をモナド値に変換する関数 e -> m a を受け取り、モナド値を返すもの

#+begin_src haskell
trapError action = catchError action (return . show)
#+end_src

action (Either モナド)の結果が正常であれば当然処理すべきエラー情報はないのでそのままのモナド値が返る

エラーが発生している場合は、第2引数に指定された (return . show) によりエラー情報が ThrowsError の Right に設定される (handle previous errors and return to normal execution)

*** 関数適用の戻り値を Either に変換することに伴う他の変更

Either モナド導入前の関数適用の評価関数は以下の通り

#+begin_src haskell
eval (List (Atom func : args)) = apply func $ map eval args
#+end_src

リスト args に対して eval を map 適用し、返ってきたリストを引数にして func を apply することで逆にしている

Either モナド導入によって以下の通り変更

#+begin_src haskell
eval (List (Atom func : args)) = mapM eval args >>= apply func
#+end_src

mapM は第2引数に持つモナドの中の値に対して第1引数の関数を適用し、第2引数と同じ型のモナドを返すもの

>>= によって mapM の結果のモナドの中の値を右の処理に渡していて(bind)、ここではその値に対して func を apply している

あとは算術計算の関数系を例にすると

#+begin_src haskell
-- Either 導入前
numericBinOp op params = Number $ foldl1 op $ map unpackedNum params
-- Either 導入後
numericBinOp op params = mapM unpackedNum params >>= return . Number . foldl1 op
#+end_src

unpackedNum が ThrowsError モナドを戻り値として返すので、 unpackedNum params で引数の数値リストを LispVal から Number 型に変換するのに mapM を用いている

ここでも >>= bind によって mapM の結果のモナドの中の値を右の関数に渡している

右では fold1 op でリストを左から畳み込んで、その結果を Number に変換し、さらに return で ThrowsError に上げて返す
