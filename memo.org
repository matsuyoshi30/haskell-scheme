#+title: MEMO
#+author: matsuyoshi30

* Parsing

** parseNumber の do-notation 記法を使わない書き方

#+begin_src haskell
parseNumber = do
  n <- many1 digit
  return $ (Number . read) n
-- とか
parseNumber = many1 digit >>= return . Number . read
parseNumber = many1 digit >>= \x -> return $ (Number . read) x
#+end_src

最初に

#+begin_src haskell
parseNumber = many1 digit >>= Number . read
#+end_src

って書いてたけど間違いで、 >>= の先の関数は bind 元と同じモナドを返さないといけなかった

#+begin_src
Main.hs:45:31: error:
    • Couldn't match type ‘LispVal’
                     with ‘Text.Parsec.Prim.ParsecT
                             String () Data.Functor.Identity.Identity LispVal’
      Expected type: [Char]
                     -> Text.Parsec.Prim.ParsecT
                          String () Data.Functor.Identity.Identity LispVal
        Actual type: String -> LispVal
    • In the second argument of ‘(>>=)’, namely ‘Number . read’
      In the expression: many1 digit >>= Number . read
      In an equation for ‘parseNumber’:
          parseNumber = many1 digit >>= Number . read
   |
45 | parseNumber = many1 digit >>= Number . read
   |
#+end_src

というエラー

** parseString を \" に対応させる

エスケープ文字をパーズする関数を作る

#+begin_src haskell
escapeChar :: Parser Char
escapeChar = do
  _ <- char '\\' -- backslash
  x <- oneOf "\\\"" -- backslask or double-quote
  return x
#+end_src

** 2進数を10進数に変換する

以下の通り変換できる

#+begin_src haskell
bin2dig = bin2dig' 0
bin2dig' digint "" = digint
bin2dig' digint (x:xs) =
  let old = 2 * digint + (if x == '0' then 0 else 1)
  in bin2dig' old xs
#+end_src

10111(23)を例に見てみる

#+begin_src haskell
bin2dig "10111"

bin2dig' 0 "1":"0111" =
  let old = 2 * 0 + 1
  in big2dig' old "0111"

     big2dig' 1 "0":"111" =
       let old = 2 * 1 + 0
       in big2dig' old "111"

          bin2dig' 2 "1":"11" =
            let old = 2 * 2 + 1
            in big2dig' old "11"

               bin2dig' 5 "1":"1" =
                 let old = 2 * 5 + 1
                 in big2dig' old "1"

                    big2dig' 11 "1" =
                      let old = 2 * 11 + 1
                      in big2dig' old ""

                         big2dig' 23 "" = 23
#+end_src

** R5RS の Character 対応

https://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.4

"#\" のあとに space や newline や一文字アルファベット、数字、左括弧が来たら Character としてパーズする

#+begin_src haskell
parseCharacter = do
  ch <- try $ do
    _ <- char '#'
    _ <- char '\\'
    c <- string "space" <|> string "newline" <|> do -- space か newline か一文字 anyChar
      x <- anyChar
      _ <- notFollowedBy alphaNum -- アルファベットもしくは数字が二文字以降に続くならパーズ失敗
      return [x]
    return c
  return $ Character $ case ch of
    "space" -> ' '
    "newline" -> '\n'
    _ -> ch !! 0
#+end_src

[[https://tnomura9.exblog.jp/15060690/][notFollowedBy について]]

** Haskell の分数表記

http://labs.timedia.co.jp/2012/11/haskell-1.html

/ のかわりに % を使うと有理数計算ができる( Data.Ratio のインポートが必要)

** List のパーズ

[[https://hackage.haskell.org/package/parsec-3.1.15.0/docs/Text-Parsec-Combinator.html#v:sepBy][sepBy]] で指定された区切り文字の内容をリスト化して返す

expr1, expr2, expr3 が [expr1, expr2, expr3] になる

リストの要素は Expr

** DottedList のパーズ

[[https://groups.csail.mit.edu/mac/ftpdir/scheme-7.4/doc-html/scheme_8.html][DottedList]] scheme では (a b . c) みたいな形でリストかける improper だけど

expr1 expr2 expr3 (最後も空白あり)が [expr1, expr2, expr3] になる

[[https://hackage.haskell.org/package/parsec-3.1.15.0/docs/Text-Parsec-Combinator.html#v:endBy][endBy]] で指定された内容と区切り文字の内容をリスト化して返す

** Vector のパーズ

#( で始まる文字列を Vector としてパーズする

[[https://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.6][scheme の Vector]] は要素数が固定されているので、 Haskell-Scheme の内部的には Data.Array を用いて Array としてデータを保持する

#+begin_src haskell
parseVector = do
  es <- try $ do
    _ <- char '#'
    _ <- char '('
    vals <- sepBy parseExpr spaces -- カッコ内の要素を LispVal のリストとしてパーズ
    _ <- char ')'
    return vals
  return $ Vector (listArray (0, (length es - 1)) es) -- Data.Array の listArray でリストを Array に変換
#+end_src

* Evaluation

** 関数適用

関数が第一級オブジェクトなので引数に持てる

関数適用のケースでは、リストの戦闘要素が関数として評価できる場合、その関数の処理内容を引っ張ってきてリストの残りの引数群に適用させればよい

ここでは以下のとおり apply を実装

#+begin_src haskell
apply :: String -> [LispVal] -> LispVal
apply func args = maybe (Bool False) ($ args) $ lookup func primitives
#+end_src

primitives に事前に定義した関数をターゲットに、評価対象の文字列が lookup で引っ張ってこれるか試す

引っ張ってこれなかったら Bool False を返すが、引っ張ってくることができれば引っ張ってきた処理内容を引数 args に適用する

#+begin_src haskell
maybe :: b -> (a -> b) -> Maybe a -> b
#+end_src

maybe は、第1引数には失敗したときに返す値を、第2引数には第3引数が渡されたときに第1引数と同じ型を返す関数を渡す

ここでは第1引数は lookup が失敗したとき（ primitives に適用できる関数がなかった）に返す Bool False :: LispVal が、第2引数にはセクション化された関数適用演算子と args が、第3引数には lookup の結果が渡されている

lookup が成功したときは、その結果の値が第2引数に渡した関数に適用されて、その結果が maybe の結果として返される。そのため、第1引数の型と、第2引数の関数が返す型は同じでなければならない

中置記法の $ は関数適用演算子だが、セクション化することで引数 args を適用する、引数に関数を期待する関数として書くことができる

#+begin_src haskell
-- Prelude> :t ($ 1)
($ 1) :: Num a => (a -> b) -> b
#+end_src
